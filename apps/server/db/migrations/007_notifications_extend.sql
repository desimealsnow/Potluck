-- Notifications â€“ schema extensions for richer inbox + delivery
-- 1) Extend notifications table (priority, actor_user_id, item_id, delivered_channels)
-- 2) Broaden allowed type values
-- 3) Add notification_preferences and push_tokens tables with RLS

BEGIN;

-- 1) Extend notifications table columns (idempotent)
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_schema='public' AND table_name='notifications' AND column_name='priority'
  ) THEN
    ALTER TABLE public.notifications
      ADD COLUMN priority smallint NOT NULL DEFAULT 0;
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_schema='public' AND table_name='notifications' AND column_name='actor_user_id'
  ) THEN
    ALTER TABLE public.notifications
      ADD COLUMN actor_user_id uuid REFERENCES auth.users(id) ON DELETE SET NULL;
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_schema='public' AND table_name='notifications' AND column_name='item_id'
  ) THEN
    -- event items table name: event_items
    ALTER TABLE public.notifications
      ADD COLUMN item_id uuid REFERENCES public.event_items(id) ON DELETE SET NULL;
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_schema='public' AND table_name='notifications' AND column_name='delivered_channels'
  ) THEN
    ALTER TABLE public.notifications
      ADD COLUMN delivered_channels jsonb NOT NULL DEFAULT '[]'::jsonb;
  END IF;
END $$;

-- 2) Relax/broaden type constraint
-- Drop implicit constraint if it exists, then add our explicit one
DO $$
BEGIN
  IF EXISTS (
    SELECT 1 FROM pg_constraint c
    JOIN pg_class t ON c.conrelid = t.oid
    JOIN pg_namespace n ON n.oid = t.relnamespace
    WHERE t.relname = 'notifications' AND n.nspname = 'public' 
      AND c.conname = 'chk_notifications_type'
  ) THEN
    ALTER TABLE public.notifications DROP CONSTRAINT chk_notifications_type;
  END IF;
  -- Also try the default autogenerated name if present
  IF EXISTS (
    SELECT 1 FROM pg_constraint c
    JOIN pg_class t ON c.conrelid = t.oid
    JOIN pg_namespace n ON n.oid = t.relnamespace
    WHERE t.relname = 'notifications' AND n.nspname = 'public' 
      AND c.conname = 'notifications_type_check'
  ) THEN
    ALTER TABLE public.notifications DROP CONSTRAINT notifications_type_check;
  END IF;
END $$;

ALTER TABLE public.notifications
  ADD CONSTRAINT chk_notifications_type
  CHECK (type IN (
    'event_created',
    'event_updated',
    'event_cancelled',
    'join_request',             -- generic legacy
    'join_request_received',    -- host sees inbound request
    'request_approved',
    'request_declined',
    'request_waitlisted',
    'reminder',
    'item_unclaimed',
    'item_assigned',
    'item_updated',
    'hold_extended',
    'hold_expiring_soon',
    'hold_expired',
    'invite_received'
  ));

-- Helpful index for unread ordering (user_id + created_at desc)
CREATE INDEX IF NOT EXISTS idx_notifications_user_created_at_desc
  ON public.notifications (user_id, created_at DESC);

-- 3) Preferences table
CREATE TABLE IF NOT EXISTS public.notification_preferences (
  user_id uuid PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  push_enabled boolean NOT NULL DEFAULT false,
  email_enabled boolean NOT NULL DEFAULT false,
  in_app_enabled boolean NOT NULL DEFAULT true,
  invite_received boolean NOT NULL DEFAULT true,
  request_approved boolean NOT NULL DEFAULT true,
  request_declined boolean NOT NULL DEFAULT true,
  request_waitlisted boolean NOT NULL DEFAULT true,
  event_updated boolean NOT NULL DEFAULT true,
  event_cancelled boolean NOT NULL DEFAULT true,
  reminder boolean NOT NULL DEFAULT true,
  item_unclaimed boolean NOT NULL DEFAULT true,
  updated_at timestamptz NOT NULL DEFAULT now()
);

ALTER TABLE public.notification_preferences ENABLE ROW LEVEL SECURITY;

-- RLS: owner can select/insert/update own preferences
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies WHERE schemaname = 'public' AND tablename = 'notification_preferences' AND policyname = 'Owner can select prefs'
  ) THEN
    CREATE POLICY "Owner can select prefs" ON public.notification_preferences
      FOR SELECT USING (auth.uid() = user_id);
  END IF;
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies WHERE schemaname = 'public' AND tablename = 'notification_preferences' AND policyname = 'Owner can upsert prefs'
  ) THEN
    CREATE POLICY "Owner can upsert prefs" ON public.notification_preferences
      FOR INSERT WITH CHECK (auth.uid() = user_id);
  END IF;
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies WHERE schemaname = 'public' AND tablename = 'notification_preferences' AND policyname = 'Owner can update prefs'
  ) THEN
    CREATE POLICY "Owner can update prefs" ON public.notification_preferences
      FOR UPDATE USING (auth.uid() = user_id);
  END IF;
END $$;

-- 4) Push tokens table
CREATE TABLE IF NOT EXISTS public.push_tokens (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  platform text NOT NULL CHECK (platform IN ('ios','android','web')),
  token text NOT NULL UNIQUE,
  created_at timestamptz NOT NULL DEFAULT now(),
  last_seen_at timestamptz NOT NULL DEFAULT now()
);

ALTER TABLE public.push_tokens ENABLE ROW LEVEL SECURITY;

-- RLS: owner can manage own tokens
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies WHERE schemaname = 'public' AND tablename = 'push_tokens' AND policyname = 'Owner can insert tokens'
  ) THEN
    CREATE POLICY "Owner can insert tokens" ON public.push_tokens
      FOR INSERT WITH CHECK (auth.uid() = user_id);
  END IF;
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies WHERE schemaname = 'public' AND tablename = 'push_tokens' AND policyname = 'Owner can select tokens'
  ) THEN
    CREATE POLICY "Owner can select tokens" ON public.push_tokens
      FOR SELECT USING (auth.uid() = user_id);
  END IF;
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies WHERE schemaname = 'public' AND tablename = 'push_tokens' AND policyname = 'Owner can update tokens'
  ) THEN
    CREATE POLICY "Owner can update tokens" ON public.push_tokens
      FOR UPDATE USING (auth.uid() = user_id);
  END IF;
END $$;

COMMENT ON TABLE public.notification_preferences IS 'Per-user notification channel and type preferences';
COMMENT ON TABLE public.push_tokens IS 'Device tokens for push notifications (Expo/Web)';

COMMIT;

